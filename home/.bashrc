#!/bin/bash
# shellcheck disable=SC1090,SC1091

# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
echo $- | grep -F i >/dev/null || return

# Terminal logging for interactive shells
#
# Check if not yet under script
if [ -z "$UNDER_SCRIPT" ]; then
  # set the logdir
  logdir="$XDG_DATA_HOME/terminal-logs"
  if [ ! -d "$logdir" ]; then
    mkdir -p "$logdir"
  fi
  # find the logs older than 30 days
  old_logs=()
  while IFS='' read -r line; do old_logs+=("$line"); done < <(find "$logdir" -type f -name "*.log" -mtime +30)
  if [ ${#old_logs[@]} -gt 0 ]; then
    echo -n "Compressing old logs..."
    for i in "${old_logs[@]}"; do
      # compress the logs older than 30 days
      gzip "$i"
    done
    echo " Done"
  fi
  # set the new logfile and start the interactive terminal with script
  logfile="$logdir/$(date +%F_%T).$$.log"
  export UNDER_SCRIPT="$logfile"
  if command -v script >/dev/null; then
    if script -f -q "$logfile"; then
      # exit the parent shell when script is finished
      exit
    else
      # there was a problem running script, reset the terminal
      reset
    fi
  fi
fi

#
# Check and start either ssh-pageant or ssh-agent
#
for agent in /usr/bin/ssh-pageant /usr/bin/ssh-agent; do
  if [ -x "$agent" ]; then
    # Create .ssh if not exists
    if [ ! -d "$HOME"/.ssh ]; then
      mkdir "$HOME"/.ssh
    fi

    export SSH_ENV="$HOME/.ssh/environment"

    # Check if SSH_ENV exists, and if the SSH_AGENT_PID inside it is still running
    if [ -f "$SSH_ENV" ]; then
      pid="$(sed -n 's/^SSH_.*_PID=\([0-9]\+\).*$/\1/p' "$SSH_ENV")"
      if [ -d /proc/"$pid" ] && [ "$agent" == "$(tr -d '\0' </proc/"$pid"/cmdline)" ]; then
        source "$SSH_ENV" >/dev/null
      fi
    fi

    # Check if ssh-agent is already running
    # Taken from: https://stackoverflow.com/a/48509425
    /usr/bin/ssh-add -l &>/dev/null
    add_retval="$?"

    # Only launch a new ssh-agent if ssh-add gives return code 2 or 3.
    # GNOME keyring only sets SSH_AGENT_LAUNCHER and SSH_AUTH_SOCK,
    # so only check for SSH_AUTH_SOCK.
    if [ "$add_retval" -gt 1 ] || [ -z "$SSH_AUTH_SOCK" ]; then
      # On Cygwin Pageant creates a sock like this:
      # \\.\pipe\ssh-pageant
      # This breaks the file and socket tests, so check for this
      # case first
      if [[ "$SSH_AUTH_SOCK" =~ ^\\\\.* ]] || [ ! -S "$SSH_AUTH_SOCK" ]; then
        echo -n "Initialising new SSH agent..."
        "$agent" > "$SSH_ENV"
        echo " Done"
        chmod 600 "$SSH_ENV"
        source "$SSH_ENV" >/dev/null
	break
      fi
    fi
  fi
done

#
# Concat SSH config scripts if any
#
if [ -d "$HOME"/.ssh/config.d ] && [ "$(ls -A "$HOME"/.ssh/config.d)" ]; then
  # concat .conf and .config files as well
  echo -e "# Do not edit this file manually!\n# It is automatically generated from the .ssh/config.d folder.\n" >"$HOME/.ssh/config"
  cat "$HOME"/.ssh/config.d/{*.conf,*.config} >>"$HOME"/.ssh/config 2>/dev/null
  chmod 600 "$HOME"/.ssh/config
fi

#
# Create screen directory, and configure environment variable
#
if [ ! -d "$HOME/.screen" ]; then
  mkdir "$HOME/.screen" && chmod 700 "$HOME/.screen"
fi
export SCREENDIR=$HOME/.screen

export PATH="$PATH:$HOME/bin"

#
# EXPORTS

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
export HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
export HISTSIZE=10000
export HISTFILESIZE=20000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# setup customized prompt command
# shellcheck disable=2154
export PROMPT_COMMAND='PS1X=$(p="${PWD#${HOME}}"; [ "${PWD}" != "${p}" ] && printf "~";IFS=/; for q in ${p:1}; do printf "%s" "/${q:0:1}"; done; printf "%s" "${q:1}")'
export PS1='[\u@\[\e[0;34m\]\h\[\e[m\]:$PS1X]\$ '

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# emacs-vterm directory-tracking
vterm_printf() {
    if [ -n "$TMUX" ] && { [ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ]; }; then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
    elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
    else
        printf "\e]%s\e\\" "$1"
    fi
}

vterm_prompt_end(){
    vterm_printf "51;A$(whoami)@$(hostname):$(pwd)"
}

# NOTE: we do not set PS1, because shell_prompt.sh will set PROMPT_COMMAND
# PS1=$PS1'\[$(vterm_prompt_end)\]'

# emacs-eat shell integration
[ -n "$EAT_SHELL_INTEGRATION_DIR" ] && \
  source "$EAT_SHELL_INTEGRATION_DIR/bash"

#
# SOURCING

if [ "$TERM" != "dumb" ]; then
  # source shell prompt generated by vim-airline
  [ -f "$HOME"/.config/bash/shell_prompt.sh ] && source "$HOME"/.config/bash/shell_prompt.sh
fi

# hook into direnv
command -v direnv >/dev/null && eval "$(direnv hook bash)"

# source homeshick
if [ -d "$HOME"/.homesick/repos/homeshick ]; then
  source "$HOME"/.homesick/repos/homeshick/homeshick.sh
fi

# source all .bash scripts in the bashrc.d folder
if [ -d "$HOME"/.config/bash/bashrc.d ]; then
  for f in "$HOME"/.config/bash/bashrc.d/*.sh; do source "$f"; done
fi

# source Abevjava profile
[ -f "$HOME"/.profabevjava ] && source "$HOME/.profabevjava"

#
# COMPLETIONS

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  # Only source completions when POSIX compatibility is not set
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi

  if [ -d "$HOME"/.homesick/repos/homeshick ]; then
    source "$HOME"/.homesick/repos/homeshick/completions/homeshick-completion.bash
  fi
fi

# The Guix install script checks for GUIX_ENVIRONMENT, add
# this here so that the install script does not add it again
# https://guix-install.sh/
if [ -n "$GUIX_ENVIRONMENT" ]; then
  if [[ "$PS1" =~ (.*)"\\$" ]]; then
    PS1="${BASH_REMATCH[1]} [env]\\\$ "
  fi
fi
